// XXX: PLEASE DO NOT TOUCH THIS FILE
// NOBODY IN THIS UNIVERSE KNOWS HOW THIS WORKS...
// This one is the lezer grammar

@top Program { Block }

@precedence {
    statement,
    assign,
    traceParams @cut,
    member @left,
    pow @right,
    times @left,
    plus @left,
    compare @left,
    equal @left,
    and @left,
    or @left
}

ArrayLiteral {
    LCurly Expr (Comma Expr)* Comma? RCurly
}
Literal {
    IntegerLit | RealLit | StringLit | CharLit |
    BooleanLit | KNull | ArrayLiteral
}
BooleanLit { KTrue | KFalse }
PrimitiveType { KInteger | KBoolean | KReal | KString | KChar }
ArrayRange { IntegerLit Colon IntegerLit } 
ArrayType { KArray LBracket ArrayRange (Comma ArrayRange)? RBracket KOf PrimitiveType }
Type { ArrayType | PrimitiveType }

// Exprs
Negation { Sub Expr }
Not { KNot Expr }
Grouping { LParen Expr RParen }
Typecast { PrimitiveType LParen Expr RParen }
FunctionCall { Ident LParen ArgList? RParen }
ArrayIndex { (Ident | Grouping) LBracket Expr (Comma Expr)? RBracket }
Unary { 
    Ident | Negation | Literal | Typecast | Grouping
    | Not | FunctionCall
}
Expr {
    Unary |
    ArrayIndex |
    BinaryExpr
}

BinaryExpr {
    Expr !or KOr Expr |
    Expr !and KAnd Expr |
    Expr !equal (Eq | Neq) Expr |
    Expr !compare (Gt | Lt | Geq | Leq) Expr |
    Expr !plus (Add | Sub) Expr |
    Expr !times (Mul | Div) Expr |
    Expr !pow Pow Expr
}

// Blocks, Statements
Lvalue { Ident | ArrayIndex }
CaseofBranch { Expr Colon Statement Newline }
Parameter { Ident Colon Type }
ParameterList { Parameter (Comma Parameter)* }
ArgList { Expr (Comma Expr)* }
FileIdent { Ident | StringLit | Grouping }
FileMode { KRead | KWrite | KAppend }
FileModeList { FileMode (KAnd FileMode)* }

DeclareStatement { KExport? KDeclare Ident (Comma Ident)* Colon Type }
ConstantStatement { KExport? KConstant Ident Assign Expr }
OutputStatement { (KOutput | KPrint) Expr (Comma Expr)* }
InputStatement { KInput Lvalue }
AssignStatement { Ident !assign Assign Expr }
IfStatement { KIf Expr KThen Block (KElse Block)? KEndif }
CaseofStatement { KCase KOf Expr Newline (CaseofBranch)* (KOtherwise Statement)? KEndcase }
WhileStatement { KWhile Expr KDo Block KEndwhile }
RepeatUntilStatement { KRepeat Block KUntil Expr }
ForStatement { KFor Ident Assign Expr KTo Expr (KStep Expr)? Newline Block KNext Ident }
ProcedureStatement { KExport? KProcedure Ident (LParen ParameterList RParen)? Block KEndprocedure }
FunctionStatement { KExport? KFunction Ident (LParen ParameterList RParen)? KReturns Type Block KEndfunction }
CallStatement { KCall Ident (LParen ArgList RParen)? }
ReturnStatement { KReturn Expr? }
ScopeStatement { KScope Block KEndscope }
IncludeStatement { KInclude StringLit }
TraceStatement { KTrace !traceParams (LParen Ident (Comma Ident)* RParen)? (KTo StringLit)? Block KEndtrace}
OpenfileStatement { KOpenfile FileIdent KFor FileModeList }
WritefileStatement { KWritefile FileIdent Comma Expr }
ReadfileStatement { KReadfile FileIdent Comma Lvalue }
ClosefileStatement { KClosefile FileIdent }

Statement {
    (
        DeclareStatement | ConstantStatement | OutputStatement | InputStatement
        | AssignStatement | IfStatement | CaseofStatement | WhileStatement
        | RepeatUntilStatement | ForStatement | ProcedureStatement
        | FunctionStatement | CallStatement | ReturnStatement | ScopeStatement
        | IncludeStatement | TraceStatement | OpenfileStatement
        | WritefileStatement | ReadfileStatement | ClosefileStatement | Expr
    )? Newline
}
Block { Statement* }

KTrue { @specialize<Ident, "true" | "TRUE"> }
KFalse { @specialize<Ident, "false" | "FALSE"> }
KDeclare { @specialize<Ident, "declare" | "DECLARE"> }
KOutput { @specialize<Ident, "output" | "OUTPUT"> }
KInput { @specialize<Ident, "input" | "INPUT"> }
KAnd { @specialize<Ident, "and" | "AND"> }
KOr { @specialize<Ident, "or" | "OR"> }
KNot { @specialize<Ident, "not" | "NOT"> }
KIf { @specialize<Ident, "if" | "IF"> }
KThen { @specialize<Ident, "then" | "THEN"> }
KElse { @specialize<Ident, "else" | "ELSE"> }
KEndif { @specialize<Ident, "endif" | "ENDIF"> }
KCase { @specialize<Ident, "case" | "CASE"> }
KOf { @specialize<Ident, "of" | "OF"> }
KOtherwise { @specialize<Ident, "otherwise" | "OTHERWISE"> }
KEndcase { @specialize<Ident, "endcase" | "ENDCASE"> }
KWhile { @specialize<Ident, "while" | "WHILE"> }
KDo { @specialize<Ident, "do" | "DO"> }
KEndwhile { @specialize<Ident, "endwhile" | "ENDWHILE"> }
KRepeat { @specialize<Ident, "repeat" | "REPEAT"> }
KUntil { @specialize<Ident, "until" | "UNTIL"> }
KFor { @specialize<Ident, "for" | "FOR"> }
KTo { @specialize<Ident, "to" | "TO"> }
KStep { @specialize<Ident, "step" | "STEP"> }
KNext { @specialize<Ident, "next" | "NEXT"> }
KProcedure { @specialize<Ident, "procedure" | "PROCEDURE"> }
KEndprocedure { @specialize<Ident, "endprocedure" | "ENDPROCEDURE"> }
KCall { @specialize<Ident, "call" | "CALL"> }
KFunction { @specialize<Ident, "function" | "FUNCTION"> }
KReturns { @specialize<Ident, "returns" | "RETURNS"> }
KReturn { @specialize<Ident, "return" | "RETURN"> }
KEndfunction { @specialize<Ident, "endfunction" | "ENDFUNCTION"> }
KInclude { @specialize<Ident, "include" | "INCLUDE"> }
KExport { @specialize<Ident, "export" | "EXPORT"> }
KScope { @specialize<Ident, "scope" | "SCOPE"> }
KEndscope { @specialize<Ident, "endscope" | "ENDSCOPE"> }
KPrint { @specialize<Ident, "print" | "PRINT"> }
KConstant { @specialize<Ident, "constant" | "CONSTANT"> }
KArray { @specialize<Ident, "array" | "ARRAY"> }
KTrace { @specialize<Ident, "trace" | "TRACE"> }
KEndtrace { @specialize<Ident, "endtrace" | "ENDTRACE"> }
KOpenfile { @specialize<Ident, "openfile" | "OPENFILE"> }
KReadfile { @specialize<Ident, "readfile" | "READFILE"> }
KWritefile { @specialize<Ident, "writefile" | "WRITEFILE"> }
KClosefile { @specialize<Ident, "closefile" | "CLOSEFILE"> }
KRead { @specialize<Ident, "read" | "READ"> }
KWrite { @specialize<Ident, "write" | "WRITE"> }
KAppend { @specialize<Ident, "append" | "APPEND"> }
KInteger { @specialize<Ident, "integer" | "INTEGER"> }
KReal { @specialize<Ident, "real" | "REAL"> }
KString { @specialize<Ident, "string" | "STRING"> }
KChar { @specialize<Ident, "char" | "CHAR"> }
KBoolean { @specialize<Ident, "boolean" | "BOOLEAN"> }
KNull { @specialize<Ident, "null" | "NULL"> }

@skip {
    space | 
    LineComment |
    BlockComment
}

@tokens {
    LineCommentBegin { "//" }
    BlockComment { "/*" (![\*] | "*" ![/])* "*/" }
    LineComment { LineCommentBegin ![\n]* }
    stringContentDouble { ![\\\n"]+ }
    Escape { "\\" @asciiLetter } 
    space { $[ \t]+ }
    Newline { "\n" | "\r\n" | Semicolon }
    @precedence { RealLit IntegerLit }
    RealLit { $[0-9]+ "." $[0-9]+ }
    IntegerLit { $[0-9]+ }
    StringLit {
        '"' (stringContentDouble | Escape)* '"'
    }
    CharLit {
        "'" ( ![\\\n'] | Escape ) "'"
    }
    Ident { $[a-zA-Z_] $[a-zA-Z0-9_]* }

    Neq { "<>" }
    Assign { "<-" | "â†" }
    Leq { "<=" }
    Geq { ">=" }
    Add { "+" }
    Sub { "-" }
    Mul { "*" }
    Div { "/" ![\n/] }
    Lt { "<" }
    Gt { ">" }
    Eq { "=" }
    Pow { "^" }
    LCurly { "{" }
    RCurly { "}" }
    LParen { "(" }
    RParen { ")" }
    LBracket { "[" }
    RBracket { "]" }
    Semicolon { ";" }
    Colon { ":" }
    Comma { "," }

}
