// This source code form is licensed under the GNU Affero General Public
// License version 3 (or later). If you cannot locate the LICENSE.md file at
// the root of the project, visit <http://www.gnu.org/licenses/> for more
// information.
//
// XXX: PLEASE DO NOT TOUCH THIS FILE
// NOBODY IN THIS UNIVERSE KNOWS HOW THIS WORKS...
// This one is the lezer grammar

@top Program { Block }

@precedence {
    statement,
    assign,
    traceParams @cut,
    member @left,
    pow @right,
    times @left,
    plus @left,
    compare @left,
    equal @left,
    and @left,
    or @left
}

ArrayLiteral {
    LCurly Expr (Comma Expr)* Comma? RCurly
}
Literal {
    IntegerLit | RealLit | StringLit | CharLit |
    BooleanLit | KNull | ArrayLiteral
}
BooleanLit { KTrue | KFalse }
PrimitiveType { KInteger | KBoolean | KReal | KString | KChar }
ArrayRange { IntegerLit Colon IntegerLit } 
ArrayType { KArray LBracket ArrayRange (Comma ArrayRange)? RBracket KOf PrimitiveType }
Type { ArrayType | PrimitiveType }

// Exprs
Negation { Sub Expr }
Not { KNot Expr }
Grouping { LParen Expr RParen }
Typecast { PrimitiveType LParen Expr RParen }
FunctionCall { (TIdent | LibroutineIdent) LParen ArgList? RParen }
ArrayIndex { (Ident | Grouping) LBracket Expr (Comma Expr)? RBracket }
Unary { 
    Ident | Negation | Literal | Typecast | Grouping
    | Not | FunctionCall
}
Expr {
    Unary |
    ArrayIndex |
    BinaryExpr
}

BinaryExpr {
    Expr !or KOr Expr |
    Expr !and KAnd Expr |
    Expr !equal (Eq | Neq) Expr |
    Expr !compare (Gt | Lt | Geq | Leq) Expr |
    Expr !plus (Add | Sub) Expr |
    Expr !times (Mul | Div) Expr |
    Expr !pow Pow Expr
}

// Blocks, Statements
Lvalue { Ident | ArrayIndex }
CaseofBranch { Expr Colon Statement Newline }
Parameter { Ident Colon Type }
ParameterList { Parameter (Comma Parameter)* }
ArgList { Expr (Comma Expr)* }
FileIdent { Ident | StringLit | Grouping }
FileMode { KRead | KWrite | KAppend }
FileModeList { FileMode (KAnd FileMode)* }

DeclareStatement { KExport? KDeclare Ident (Comma Ident)* Colon Type }
ConstantStatement { KExport? KConstant Ident Assign Expr }
OutputStatement { (KOutput | KPrint) Expr (Comma Expr)* }
InputStatement { KInput Lvalue }
AssignStatement { Ident !assign Assign Expr }
IfStatement { KIf Expr KThen Block (KElse Block)? KEndif }
CaseofStatement { KCase KOf Expr Newline (CaseofBranch)* (KOtherwise Statement)? KEndcase }
WhileStatement { KWhile Expr KDo Block KEndwhile }
RepeatUntilStatement { KRepeat Block KUntil Expr }
ForStatement { KFor Ident Assign Expr KTo Expr (KStep Expr)? Newline Block KNext Ident }
ProcedureStatement { KExport? KProcedure Ident (LParen ParameterList? RParen)? Block KEndprocedure }
FunctionStatement { KExport? KFunction Ident (LParen ParameterList? RParen)? KReturns Type Block KEndfunction }
CallStatement { KCall (TIdent | LibroutineIdent) (LParen ArgList RParen)? }
ReturnStatement { KReturn Expr? }
ScopeStatement { KScope Block KEndscope }
IncludeStatement { KInclude StringLit }
TraceStatement { KTrace !traceParams (LParen (Ident (Comma Ident)*)? RParen)? (KTo StringLit)? Block KEndtrace}
OpenfileStatement { KOpenfile FileIdent KFor FileModeList }
WritefileStatement { KWritefile FileIdent Comma Expr }
ReadfileStatement { KReadfile FileIdent Comma Lvalue }
ClosefileStatement { KClosefile FileIdent }

Statement {
    (
        DeclareStatement | ConstantStatement | OutputStatement | InputStatement
        | AssignStatement | IfStatement | CaseofStatement | WhileStatement
        | RepeatUntilStatement | ForStatement | ProcedureStatement
        | FunctionStatement | CallStatement | ReturnStatement | ScopeStatement
        | IncludeStatement | TraceStatement | OpenfileStatement
        | WritefileStatement | ReadfileStatement | ClosefileStatement | Expr
    )? Newline
}
Block { Statement* }

KTrue { @specialize<TIdent, "true" | "TRUE"> }
KFalse { @specialize<TIdent, "false" | "FALSE"> }
KDeclare { @specialize<TIdent, "declare" | "DECLARE"> }
KOutput { @specialize<TIdent, "output" | "OUTPUT"> }
KInput { @specialize<TIdent, "input" | "INPUT"> }
KAnd { @specialize<TIdent, "and" | "AND"> }
KOr { @specialize<TIdent, "or" | "OR"> }
KNot { @specialize<TIdent, "not" | "NOT"> }
KIf { @specialize<TIdent, "if" | "IF"> }
KThen { @specialize<TIdent, "then" | "THEN"> }
KElse { @specialize<TIdent, "else" | "ELSE"> }
KEndif { @specialize<TIdent, "endif" | "ENDIF"> }
KCase { @specialize<TIdent, "case" | "CASE"> }
KOf { @specialize<TIdent, "of" | "OF"> }
KOtherwise { @specialize<TIdent, "otherwise" | "OTHERWISE"> }
KEndcase { @specialize<TIdent, "endcase" | "ENDCASE"> }
KWhile { @specialize<TIdent, "while" | "WHILE"> }
KDo { @specialize<TIdent, "do" | "DO"> }
KEndwhile { @specialize<TIdent, "endwhile" | "ENDWHILE"> }
KRepeat { @specialize<TIdent, "repeat" | "REPEAT"> }
KUntil { @specialize<TIdent, "until" | "UNTIL"> }
KFor { @specialize<TIdent, "for" | "FOR"> }
KTo { @specialize<TIdent, "to" | "TO"> }
KStep { @specialize<TIdent, "step" | "STEP"> }
KNext { @specialize<TIdent, "next" | "NEXT"> }
KProcedure { @specialize<TIdent, "procedure" | "PROCEDURE"> }
KEndprocedure { @specialize<TIdent, "endprocedure" | "ENDPROCEDURE"> }
KCall { @specialize<TIdent, "call" | "CALL"> }
KFunction { @specialize<TIdent, "function" | "FUNCTION"> }
KReturns { @specialize<TIdent, "returns" | "RETURNS"> }
KReturn { @specialize<TIdent, "return" | "RETURN"> }
KEndfunction { @specialize<TIdent, "endfunction" | "ENDFUNCTION"> }
KInclude { @specialize<TIdent, "include" | "INCLUDE"> }
KExport { @specialize<TIdent, "export" | "EXPORT"> }
KScope { @specialize<TIdent, "scope" | "SCOPE"> }
KEndscope { @specialize<TIdent, "endscope" | "ENDSCOPE"> }
KPrint { @specialize<TIdent, "print" | "PRINT"> }
KConstant { @specialize<TIdent, "constant" | "CONSTANT"> }
KArray { @specialize<TIdent, "array" | "ARRAY"> }
KTrace { @specialize<TIdent, "trace" | "TRACE"> }
KEndtrace { @specialize<TIdent, "endtrace" | "ENDTRACE"> }
KOpenfile { @specialize<TIdent, "openfile" | "OPENFILE"> }
KReadfile { @specialize<TIdent, "readfile" | "READFILE"> }
KWritefile { @specialize<TIdent, "writefile" | "WRITEFILE"> }
KClosefile { @specialize<TIdent, "closefile" | "CLOSEFILE"> }
KRead { @specialize<TIdent, "read" | "READ"> }
KWrite { @specialize<TIdent, "write" | "WRITE"> }
KAppend { @specialize<TIdent, "append" | "APPEND"> }
KInteger { @specialize<TIdent, "integer" | "INTEGER"> }
KReal { @specialize<TIdent, "real" | "REAL"> }
KString { @specialize<TIdent, "string" | "STRING"> }
KChar { @specialize<TIdent, "char" | "CHAR"> }
KBoolean { @specialize<TIdent, "boolean" | "BOOLEAN"> }
KNull { @specialize<TIdent, "null" | "NULL"> }

LibroutineIdent {
    LUcase | LLcase | LDiv | LMod | LSubstring | LRound | LSqrt
    | LLength | LGetchar | LRandom | LPutchar | LExit | LSleep
    | LFlush | LSin | LCos | LTan | LInitarray
}
LUcase { @specialize<TIdent, "ucase" | "UCASE"> }
LLcase { @specialize<TIdent, "lcase" | "LCASE"> }
LDiv { @specialize<TIdent, "div" | "DIV"> }
LMod { @specialize<TIdent, "mod" | "MOD"> }
LSubstring { @specialize<TIdent, "substring" | "SUBSTRING"> }
LRound { @specialize<TIdent, "round" | "ROUND"> }
LSqrt { @specialize<TIdent, "sqrt" | "SQRT"> }
LLength { @specialize<TIdent, "length" | "LENGTH"> }
LGetchar { @specialize<TIdent, "getchar" | "GETCHAR"> }
LRandom { @specialize<TIdent, "random" | "RANDOM"> }
LPutchar { @specialize<TIdent, "putchar" | "PUTCHAR"> }
LExit { @specialize<TIdent, "exit" | "EXIT"> }
LSleep { @specialize<TIdent, "sleep" | "SLEEP"> }
LFlush { @specialize<TIdent, "flush" | "FLUSH"> }
LSin { @specialize<TIdent, "sin" | "SIN"> }
LCos { @specialize<TIdent, "cos" | "COS"> }
LTan { @specialize<TIdent, "tan" | "TAN"> }
LInitarray { @specialize<TIdent, "initarray" | "INITARRAY"> }

Ident { LibroutineIdent | TIdent }

@skip {
    space | 
    LineComment |
    BlockComment
}

@tokens {
    LineCommentBegin { "//" }
    BlockComment { "/*" (![\*] | "*" ![/])* "*/" }
    LineComment { LineCommentBegin ![\n]* }
    stringContentDouble { ![\\\n"]+ }
    Escape { "\\" @asciiLetter } 
    space { $[ \t]+ }
    Newline { "\n" | "\r\n" | Semicolon }
    @precedence { RealLit IntegerLit }
    RealLit { $[0-9]+ "." $[0-9]+ }
    IntegerLit { $[0-9]+ }
    StringLit {
        '"' (stringContentDouble | Escape)* '"'
    }
    CharLit {
        "'" ( ![\\\n'] | Escape ) "'"
    }
    TIdent { $[a-zA-Z_] $[a-zA-Z0-9_]* }

    Neq { "<>" }
    Assign { "<-" | "â†" }
    Leq { "<=" }
    Geq { ">=" }
    Add { "+" }
    Sub { "-" }
    Mul { "*" }
    Div { "/" ![\n/] }
    Lt { "<" }
    Gt { ">" }
    Eq { "=" }
    Pow { "^" }
    LCurly { "{" }
    RCurly { "}" }
    LParen { "(" }
    RParen { ")" }
    LBracket { "[" }
    RBracket { "]" }
    Semicolon { ";" }
    Colon { ":" }
    Comma { "," }

}
